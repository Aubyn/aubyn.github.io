import{l as e,c as r,b as t,ai as o}from"./chunks/framework.DfOqixww.js";const u=JSON.parse('{"title":"组件库选择","description":"","frontmatter":{},"headers":[],"relativePath":"blog/frontend/component.md","filePath":"blog/frontend/component.md"}'),n={name:"blog/frontend/component.md"};function l(i,a,d,h,s,c){return t(),r("div",null,a[0]||(a[0]=[o('<h1 id="组件库选择" tabindex="-1">组件库选择 <a class="header-anchor" href="#组件库选择" aria-label="Permalink to &quot;组件库选择&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>为了快速实现某个组件，最早会使用 class 类的方案（Bootstrap/Bluma）。</p><p>在前端框架发展之后，适配对应框架的组件库也繁荣发展。</p><p>当组件库越来越多，并且参与的项目中涉及到自定义组件之后，会发现组件库其实是重复造轮子，组件库有很多可以底层通用的能力，识别并抽取这些通用能力，加上组件特有逻辑，再加上 UI 规范，就可以更快地打造自定义组件，实现自己的组件库。</p><p>实现多个自定义组件库可以复用这些抽取的内容，实现减少重复造轮子，而更多地关注业务需要什么样的组件。</p><h2 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h2><p>为了快速实现项目所需的通用组件和自定义组件，采用传统的大而全的组件库已不可取，总会有不满足产品需求的组件。更适合采用带有适量通用组件，并提供组件通用能力以方便开发自定义组件的能力。</p><h2 id="选择" tabindex="-1">选择 <a class="header-anchor" href="#选择" aria-label="Permalink to &quot;选择&quot;">​</a></h2><p>Radix UI，匹配多种框架（含非官方），非常底层，只提供基础组件，没有样式，组件的样式、内容、图标都要自己填充实现。适合完全从零构建组件库。</p><p>Shadcn UI，基于 Radix UI，提供了基础组件上简单封装的组件，减少了过多细节考虑。适合快速实现需求而避免过度关注样式，👍</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://www.shadcn-vue.com/" target="_blank" rel="noreferrer">shadcn-vue</a></li><li><a href="https://www.radix-vue.com/" target="_blank" rel="noreferrer">Radix Vue</a></li><li><a href="https://ark-ui.com/" target="_blank" rel="noreferrer">Ark UI</a></li></ul>',13)]))}const _=e(n,[["render",l]]);export{u as __pageData,_ as default};

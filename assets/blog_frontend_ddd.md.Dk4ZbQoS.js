import{l as s,c as e,b as n,ai as l}from"./chunks/framework.DfOqixww.js";const u=JSON.parse('{"title":"领域驱动设计","description":"","frontmatter":{},"headers":[],"relativePath":"blog/frontend/ddd.md","filePath":"blog/frontend/ddd.md"}'),t={name:"blog/frontend/ddd.md"};function o(i,a,d,p,c,r){return n(),e("div",null,a[0]||(a[0]=[l(`<h1 id="领域驱动设计" tabindex="-1">领域驱动设计 <a class="header-anchor" href="#领域驱动设计" aria-label="Permalink to &quot;领域驱动设计&quot;">​</a></h1><h2 id="why" tabindex="-1">why <a class="header-anchor" href="#why" aria-label="Permalink to &quot;why&quot;">​</a></h2><ul><li>代码解耦，减少导入多余依赖，减少循环依赖</li><li>更好地实现数据驱动，先数据后视图。数据视图协作过程中减少多 model 相互依赖痛点。</li><li>增加可测试性</li></ul><h2 id="how" tabindex="-1">how <a class="header-anchor" href="#how" aria-label="Permalink to &quot;how&quot;">​</a></h2><p>DDD 领域驱动设计，采用分层架构提升代码的高内聚低耦合、可扩展、可测试性。</p><h3 id="○-ddd-实现思路" tabindex="-1">○ DDD 实现思路 <a class="header-anchor" href="#○-ddd-实现思路" aria-label="Permalink to &quot;○ DDD 实现思路&quot;">​</a></h3><ul><li>表示层 Presentation：展示界面，响应交互</li><li>应用层 Application：处理交互，协调调用多个领域服务完成业务逻辑。可和领域聚合根重叠。可读写分离。</li><li>领域层 Domain：封装核心业务逻辑，提供领域模型。实体是动态对象。值对象是不可变对象。聚合根封装一系列修改、读取实体、值对象等事务。</li><li>基础设施层 Infrastructure：底层公共能力，如：api 请求、消息传递等。</li></ul><h3 id="○-前端实践" tabindex="-1">○ 前端实践 <a class="header-anchor" href="#○-前端实践" aria-label="Permalink to &quot;○ 前端实践&quot;">​</a></h3><ul><li>表示层：<code>page/</code> 目录，存放页面组件；<code>domain/&lt;area&gt;/&lt;component&gt;</code> 存放局部组件。</li><li>应用层：页面组件和局部组件中，接收用户交互事件。</li><li>领域层：<code>domain/&lt;area&gt;/</code> 文件夹中，拆分 <code>type.ts</code> 类型、<code>constant.ts</code> 常量（值对象）、<code>xx.model.ts</code> 领域对象/聚合根。允许多聚合根！</li><li>基础设施层：<code>domain/&lt;area&gt;/</code> 文件夹中，拆分 <code>xx.http.ts</code> 接口、<code>xx.util.ts</code> 工具函数。</li></ul><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>page</span></span>
<span class="line"><span>  page1</span></span>
<span class="line"><span>  page2</span></span>
<span class="line"><span>domain</span></span>
<span class="line"><span>  table</span></span>
<span class="line"><span>    type.ts</span></span>
<span class="line"><span>    constant.ts</span></span>
<span class="line"><span>    table-column-builder.ts -&gt; 也属于 xx.model.ts</span></span></code></pre></div><h3 id="○-后端-go-实践" tabindex="-1">○ 后端 Go 实践 <a class="header-anchor" href="#○-后端-go-实践" aria-label="Permalink to &quot;○ 后端 Go 实践&quot;">​</a></h3><ul><li>表示层：<code>route/</code> 文件夹中，接收请求，返回响应</li><li>应用层：<code>domain/</code> 文件夹中（共用一个文件夹，对应一个 package，避免 package 起名痛苦），<code>&lt;area&gt;.reader.go</code> 读取聚合根，<code>&lt;area&gt;.writer.go</code> 写入聚合根</li><li>领域层：<code>domain/</code> 文件夹中，存放 <code>&lt;area&gt;.constant.go</code> 常量、<code>&lt;area&gt;.&lt;struct&gt;.go</code> 领域对象/聚合跟</li><li>基础设施层：<code>sql/</code> 文件夹中，存放 <code>&lt;area&gt;_read.sql</code>、<code>&lt;area&gt;_write.sql</code>，和共用的 <code>schema.sql</code>、<code>sqlc.yaml</code>。sqlc 生成的接口存放到 <code>api/</code> 文件夹中。</li></ul><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>route</span></span>
<span class="line"><span>  user.go</span></span>
<span class="line"><span>domain</span></span>
<span class="line"><span>  user.constant.go</span></span>
<span class="line"><span>  user.util.go -&gt; 也属于 &lt;area&gt;.&lt;struct&gt;.go</span></span>
<span class="line"><span>sql</span></span>
<span class="line"><span>  schema.sql -&gt; 所有表的表结构</span></span>
<span class="line"><span>  sqlc.yaml -&gt; sqlc 配置</span></span>
<span class="line"><span>  user_read.sql</span></span>
<span class="line"><span>  user_write.sql</span></span>
<span class="line"><span>dl -&gt; sqlc 自动生成，只读</span></span>
<span class="line"><span>  db.go</span></span>
<span class="line"><span>  models.go</span></span></code></pre></div><h2 id="what" tabindex="-1">what <a class="header-anchor" href="#what" aria-label="Permalink to &quot;what&quot;">​</a></h2><p>通过 DDD 的实现思路，在前后端均可实现，写出更易于维护的代码。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://docs.mryqr.com/build-your-own-software-skyscraper/" target="_blank" rel="noreferrer">码如云 DDD 领域驱动设计实践，后端开发并不只是 CRUD</a></li></ul>`,17)]))}const g=s(t,[["render",o]]);export{u as __pageData,g as default};
